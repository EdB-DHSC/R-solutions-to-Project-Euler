[
["index.html", "Worked Solutions to Project Euler in R Chapter 1 index", " Worked Solutions to Project Euler in R See contributing.md 2020-10-07 Chapter 1 index "],
["intro.html", "Chapter 2 Introduction 2.1 What is Project Euler? 2.2 Who are the problems aimed at? 2.3 How to contribute to this project? 2.4 REMEMBER: Anyone can make a PR", " Chapter 2 Introduction Project Euler Logo 2.1 What is Project Euler? Project Euler is a series of challenging mathematical/computer programming problems that will require more than just mathematical insights to solve. Although mathematics will help you arrive at elegant and efficient methods, the use of a computer and programming skills will be required to solve most problems. The motivation for starting Project Euler, and its continuation, is to provide a platform for the inquiring mind to delve into unfamiliar areas and learn new concepts in a fun and recreational context. 2.2 Who are the problems aimed at? The intended audience include students for whom the basic curriculum is not feeding their hunger to learn, adults whose background was not primarily mathematics but had an interest in things mathematical, and professionals who want to keep their problem solving and mathematics on the cutting edge. Here, in this repository you can find the solutions to the various problems for learning a language in the Project Euler. 2.3 How to contribute to this project? You may solve any problem in the scope of Project Euler and mention your name to the CONTRIBUTORS.md file. Make a pull request for your work and wait for it to be merged! 2.4 REMEMBER: Anyone can make a PR Getting started: Fork this repository Clone your fork down to your local machine git clone https://github.com/jimr1603/R-solutions-to-Project-Euler.git Create a branch git checkout -b branch-name Make your changes Commit and push git add . git commit -m &#39;Commit message&#39; git push origin branch-name Create a new pull request from your forked repository (Click the New Pull Request button located at the top of your repo) Wait for your PR review and merge approval! Star this repository if you had fun! Don’t forget to add your name to the CONTRIBUTING.md file using the below convention: #### Name: YOUR NAME - Location: Country - Bio: Who are you? Your interests? - GitHub: [GitHub account name](GitHub link) "],
["problems1.html", "Chapter 3 Problem set 1 3.1 Intro 3.2 Problem 1 3.3 Problem 2 3.4 Problem 3", " Chapter 3 Problem set 1 3.1 Intro For this section I’m planning on giving two solutions - one in base R, one with Tidyverse. I hope to demonstrate that Tidyverse solutions are easier to follow. 3.2 Problem 1 Multiples of 3 and 5 If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23. Find the sum of all the multiples of 3 or 5 below 1000. 3.2.1 Base R For this I’d like to start with a vector from 1:1000: x &lt;- 1:999 Then filter for multiples of 3 or 5: x &lt;- x[x %% 3 == 0 | x %% 5 == 0] # x modulo 3 = 0 or x modulo 5 = 0. And finally, sum: sum(x) ## [1] 233168 3.2.2 Tidyverse This is easy enough to do with a single pipe: library(&quot;tidyverse&quot;) tibble(x = 1:999) %&gt;% # Start with all numbers 1:999 filter(x %% 3 == 0 | x %% 5 == 0) %&gt;% # keep multiples of 3 or 5 summarise(solution = sum(x)) %&gt;% # Add them together knitr::kable() # Print it as a table solution 233168 3.2.3 Other Comments You can also do this as an inclusion/exclusion problem. You can add up the multiples of 3, plus the multiples of 5, but then you’ve double-counted the multiples of 3 &amp; 5, so you need to subtract the multiples of 15. R has no problems with a 999-element vector, so in this case I prefer starting with every integer and filtering down to reduce the risk of programmer error. 3.3 Problem 2 Even Fibonacci numbers Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be: 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, … By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms. 3.3.1 Base R We need a loop to define the next Fibonacci number. fib &lt;- c(1, 1) while (fib[length(fib)] &lt; 4000000) { new_fib &lt;- fib[length(fib)] + fib[length(fib) - 1] # sum of last 2 values fib &lt;- c(fib, new_fib) # extend the vector } Then filter and sum: sum(fib[fib %% 2 == 0 &amp; fib &lt; 4000000]) ## [1] 4613732 3.3.2 Tidyverse We still need our loop, but we can use {dplyr}’s last function. fib &lt;- c(1, 1) while (last(fib) &lt; 4000000) { new_fib &lt;- last(fib) + nth(fib, -2) # sum of last 2 values fib &lt;- c(fib, new_fib) # extend the vector } Then the filter and sum is a bit clearer: tibble(fib) %&gt;% filter(fib &lt; 4000000, fib %% 2 == 0) %&gt;% summarise(sum = sum(fib)) %&gt;% knitr::kable() sum 4613732 3.4 Problem 3 The prime factors of 13195 are 5, 7, 13 and 29. What is the largest prime factor of the number 600851475143 ? Largest prime factor The prime factors of 13195 are 5, 7, 13 and 29. What is the largest prime factor of the number 600851475143 ? 3.4.1 Base R We need two tools for this - a test for what numbers are factors of 600851475143, and what numbers are prime. Base R has %% which gives divisibility. If x %% y == 0 then x divided by y leaves remainder 0, i.e. y is a factor of x. A prime number is one that only has 1 and itself as a factor. It is sufficient to test up to the square root of the number we’re testing. We can write that as a function: is_prime &lt;- function(x) { # Tests if x is prime # RETURNS: # True if x is prime # False if x is not prime if (x != round(x)) return(FALSE) # x is not a whole number if (x == 2) return(TRUE) # test below fails on 2 test &lt;- seq(from = 2, to = ceiling(sqrt(x)), by = 1) all(x %% test != 0) } I would normally start with a vector 1:600851475143, but my machine refuses to build a vector that will be 4 Tb in size! If 600851475143 is prime, then this question is slightly boring. target &lt;- 600851475143 is_prime(target) ## [1] FALSE So 6.008514810^{11} is not prime, so we are looking for a proper factor. factors &lt;- seq(from = 2, to = ceiling(sqrt(target))) factors &lt;- factors[target %% factors == 0] # which of these numbers are factors? prime_factors &lt;- c() for (i in factors) { if (is_prime(i)) { prime_factors &lt;- c(prime_factors, i) } } max(prime_factors) # which prime factor is largest? ## [1] 6857 The for-loop was necessary because my is_prime function is not vectorised. 3.4.2 Tidyverse I will keep is_prime. tibble(x = seq(from = 2, to = ceiling(sqrt(target)))) %&gt;% filter(target %% x == 0) %&gt;% mutate(prime = map_lgl(x, is_prime)) %&gt;% filter(prime) %&gt;% select(-prime) %&gt;% slice_max(x) %&gt;% rename(prime_factor = x) %&gt;% knitr::kable() prime_factor 6857 The map_lgl lets us use the is_prime function which only expects 1 number at a time, and apply it to each factor of 6.008514810^{11} in turn. The rest is filtering that we should be familiar with by now. 3.4.3 Closing Now that we know that we can write code that tests for prime-ness, I’m going to use the Primes package from now on. This is not cheating! Using library functions reduces the chance of us making errors, and is often faster than what we would think of writing. "]
]
