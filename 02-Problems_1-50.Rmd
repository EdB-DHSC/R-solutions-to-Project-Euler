# Problem set 1 {#problems1}

## Intro

For this section I'm planning on giving two solutions - one in base R, one with Tidyverse. I hope to demonstrate that Tidyverse solutions are easier to follow.

## Problem 1

[Multiples of 3 and 5](https://projecteuler.net/problem=1)

>   If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.
>
> Find the sum of all the multiples of 3 or 5 below 1000.

### Base R

For this I'd like to start with a vector from 1:1000:

```{r}
x <- 1:999
```

Then filter for multiples of 3 or 5:

```{r}
x <- x[x %% 3 == 0 | x %% 5 == 0] # x modulo 3 = 0 or x modulo 5 = 0.
```

And finally, sum:

```{r}
sum(x)
```

### Tidyverse

This is easy enough to do with a single pipe:

```{r, message=FALSE}
library("tidyverse")
tibble(x = 1:999) %>% # Start with all numbers 1:999
  filter(x %% 3 == 0 | x %% 5 == 0) %>% # keep multiples of 3 or 5
  summarise(solution = sum(x)) %>% # Add them together
  knitr::kable() # Print it as a table
```

### Other Comments

You can also do this as an inclusion/exclusion problem. You can add up the multiples of 3, plus the multiples of 5, but then you've double-counted the multiples of 3 & 5, so you need to subtract the multiples of 15. 

R has no problems with a 999-element vector, so in this case I prefer starting with every integer and filtering down to reduce the risk of programmer error. 

## Problem 2

[Even Fibonacci numbers](https://projecteuler.net/problem=2)

> Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:
>
>1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
>
>By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.


### Base R

We need a loop to define the next Fibonacci number.

```{r}
fib <- c(1, 1)

while (fib[length(fib)] < 4000000) {
  new_fib <- fib[length(fib)] + fib[length(fib) - 1] # sum of last 2 values
  fib <- c(fib, new_fib) # extend the vector
}

```

Then filter and sum:

```{r}

sum(fib[fib %% 2 == 0 & fib < 4000000])

```

### Tidyverse

We still need our loop, but we can use {dplyr}'s `last` function.

```{r}
fib <- c(1, 1)

while (last(fib) < 4000000) {
  new_fib <- last(fib) + nth(fib, -2) # sum of last 2 values
  fib <- c(fib, new_fib) # extend the vector
}
```


Then the filter and sum is a bit clearer:

```{r}
tibble(fib) %>%
  filter(fib < 4000000, fib %% 2 == 0) %>%
  summarise(sum = sum(fib)) %>%
  knitr::kable()
```

## Problem 3


The prime factors of 13195 are 5, 7, 13 and 29.

What is the largest prime factor of the number 600851475143 ?

[Largest prime factor](https://projecteuler.net/problem=3)

> The prime factors of 13195 are 5, 7, 13 and 29.
>
> What is the largest prime factor of the number 600851475143 ?

### Base R

We need two tools for this - a test for what numbers are factors of 600851475143, and what numbers are prime.

Base R has `%%` which gives divisibility. If `x %% y == 0` then x divided by y leaves remainder 0, i.e. y is a factor of x.

A prime number is one that only has 1 and itself as a factor. It is sufficient to test up to the square root of the number we're testing. We can write that as a function:

```{r}
is_prime <- function(x) {
  # Tests if x is prime
  # RETURNS:
  # True if x is prime
  # False if x is not prime

  if (x != round(x)) return(FALSE) # x is not a whole number
  if (x == 2) return(TRUE) # test below fails on 2

  test <- seq(from = 2,
      to = ceiling(sqrt(x)),
      by = 1)
  
  all(x %% test != 0)
}
```

I would normally start with a vector `1:600851475143`, but my machine refuses to build a vector that will be 4 Tb in size! If 600851475143 is prime, then this question is slightly boring.

```{r}
target <- 600851475143

is_prime(target)
```

So `r target` is not prime, so we are looking for a proper factor.

```{r}
factors <- seq(from = 2,
               to = ceiling(sqrt(target)))

factors <- factors[target %% factors == 0] # which of these numbers are factors?

prime_factors <- c()

for (i in factors) {
  if (is_prime(i)) {
    prime_factors <- c(prime_factors, i)
  }
}

max(prime_factors) # which prime factor is largest?

```

The for-loop was necessary because my `is_prime` function is not vectorised.

### Tidyverse 

I will keep `is_prime`.

```{r}
tibble(x = seq(from = 2,
               to = ceiling(sqrt(target)))) %>%
         filter(target %% x == 0) %>%
  mutate(prime = map_lgl(x, is_prime)) %>%
  filter(prime) %>%
  select(-prime) %>%
  slice_max(x) %>%
  rename(prime_factor = x) %>%
  knitr::kable()
```

The `map_lgl` lets us use the `is_prime` function which only expects 1 number at a time, and apply it to each factor of `r target` in turn. The rest is filtering that we should be familiar with by now.


### Closing

Now that we know that we can write code that tests for prime-ness, I'm going to use the [Primes](https://rdrr.io/cran/primes/f/README.md) package from now on. *This is not cheating!* Using library functions reduces the chance of us making errors, and is often faster than what we would think of writing. 