# Problem set 1 {#problems1}

## Intro

For this section I'm planning on giving two solutions - one in base R, one with Tidyverse. I hope to demonstrate that Tidyverse solutions are easier to follow.

## Problem 1

[Multiples of 3 and 5](https://projecteuler.net/problem=1)

>   If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.
>
> Find the sum of all the multiples of 3 or 5 below 1000.

### Base R

For this I'd like to start with a vector from 1:1000:

```{r}
x <- 1:999
```

Then filter for multiples of 3 or 5:

```{r}
x <- x[x %% 3 == 0 | x %% 5 == 0] # x modulo 3 = 0 or x modulo 5 = 0.
```

And finally, sum:

```{r}
sum(x)
```

### Tidyverse

This is easy enough to do with a single pipe:

```{r, message=FALSE}
library("tidyverse")
tibble(x = 1:999) %>% # Start with all numbers 1:999
  filter(x %% 3 == 0 | x %% 5 == 0) %>% # keep multiples of 3 or 5
  summarise(solution = sum(x)) %>% # Add them together
  knitr::kable() # Print it as a table
```

### Other Comments

You can also do this as an inclusion/exclusion problem. You can add up the multiples of 3, plus the multiples of 5, but then you've double-counted the multiples of 3 & 5, so you need to subtract the multiples of 15. 

R has no problems with a 999-element vector, so in this case I prefer starting with every integer and filtering down to reduce the risk of programmer error. 

## Problem 2

[Even Fibonacci numbers](https://projecteuler.net/problem=2)

> Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:
>
>1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
>
>By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.


### Base R

We need a loop to define the next Fibonacci number.

```{r}
fib <- c(1, 1)

while (fib[length(fib)] < 4000000) {
  new_fib <- fib[length(fib)] + fib[length(fib) - 1] # sum of last 2 values
  fib <- c(fib, new_fib) # extend the vector
}

```

Then filter and sum:

```{r}

sum(fib[fib %% 2 == 0 & fib < 4000000])

```

### Tidyverse

We still need our loop, but we can use {dplyr}'s `last` function.

```{r}
fib <- c(1, 1)

while (last(fib) < 4000000) {
  new_fib <- last(fib) + nth(fib, -2) # sum of last 2 values
  fib <- c(fib, new_fib) # extend the vector
}
```


Then the filter and sum is a bit clearer:

```{r}
tibble(fib) %>%
  filter(fib < 4000000, fib %% 2 == 0) %>%
  summarise(sum = sum(fib)) %>%
  knitr::kable()
```